# **SOLID**
객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙을 첫 글자만 따서 만든 단어이다.
객체 지향 프로그래밍의 가장 큰 장점은 '역할과 구현이 구분되어있어, 각 객체에 대해 무한한 확장성을 지닌다'는 점이라고 생각한다.
그러한 관점에서, SOLID의 각 항목은 객체 지향 프로그래밍의 장점을 더욱 잘 살리기위한 프로그래밍 원칙이라고 받아들이면 되겠다.

##  S - SRP(Single Responsibility principle) 
> **"한 클래스는하나의 책임만 가져야 하고, 그 책임을 수행하는데 집중되어 있어야 한다."**

SRP는 '단일 책임 원칙'을 의미한다. 한 클래스는 하나의 책임만 가져야 한다는 원칙인데, 이 책임이 다소 모호한 느낌이 있다.   
만약 '문서를 만든다' 라는 역할을 구현한 클래스가 있을 때 이 클래스를 수정해야하는 상황은    
* 문서의 구성 방식이 수정됨 (내용적)
* 문서의 서식이 수정됨 (꾸미기?)   

와 같이 나눠질 것이다. SRP 원칙에 따르면, 구성 방식과 서식 또한 각각 하나의 책임이며, SRP를 지키기 위해서는 분리되어야 한다고 주장한다.   

##  O - OCP(Open/Closed Principle) 
OCP는 '개방/폐쇄 원칙'을 의미한다. OCP를 한 문장으로 요약하면 다음과 같다
> **"소프트웨어 요소는 확장에는 열려있으나, 변경에는 닫혀있어야 한다."**

이 원칙은 추상성, 다형성과 연결된다. 요구 사항의 변경이나 추가할 사항이 발생했을 때, 기존 구성요소는 변경이 일어나지 않아야 하며, 
기존 구성요소를 쉽게 확장하여 재사용 할 수 있어야 한다는 것이 OCP의 핵심 내용이다.   
인터페이스를 만들고, 구현 클래스를 통해 실제 기능을 제공한다고 생각하면 될 것이다.   

## L - LSP(Liskov Substitution Principle)
> **"프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다."**

LSP는 '리스코프 치환 원칙'을 의미한다. 다형성의 관점에서 하위 클래스는 인터페이스의 규약을 모두 지켜야 한다는 원칙이다.   
인터페이스를 구현한 구현체를 신뢰하기 위해서는 이 원칙이 필수라고 할 수 있다.   
이 원칙을 설명하기 위한 대표적인 예시는 다음과 같다.
```
자동차 인터페이스 - moveForward() - 실제 기능 : 앞으로 간다.
구현체 클래스 - @Overriding moveForward() - 실제 기능 : 뒤로 간다.
```
위와 같이 구현체에서 구현할 때, 인터페이스에서 설정한 규약을 어겨서는 안된다.   
인터페이스에서 설정한 규약이 잘못되었다면 인터페이스를 수정하는 것이 옳으며, 설령 규약이 잘못되었더라도 그것을 구현체에서 바로 잡아서는 안된다.   

##  I - ISP(Interface Segregation Principle) 
> **"특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다."**

ISP는 '인터페이스 분리 원칙'을 의미한다. 일반적인 인터페이스 하나보다, 좀 더 구체적인 인터페이스를 여러 개 지정하여, 
클라이언트가 꼭 필요한 메서드만 사용할 수 있도록 해야한다.   
이런 방식으로 설계할 경우, 각 인터페이스의 기능이 명확해지며 대체 가능성이 높아진다.

## D - DIP(Dependency Inversion Principle)
> **"프로그래머는 '추상화'에 의존해야지, '구체화'에 의존하면 안된다. 의존성 주입(DI)는 이 원칙을 따르는 방법 중 하나다."**

DIP는 '의존 역전 원칙'을 의미한다. 구현 클래스가 아니라, 인터페이스에 의존하라는 의미이다.   
인터페이스에 의존하게 되면, 구현 클래스에 대해서는 몰라도 되기 때문에 구현체를 유연하게 변경할 수 있다.
