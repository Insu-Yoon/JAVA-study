# **시간 복잡도란?**

시간 복잡도를 간단하게 표현하면 "입력값(n)의 변화에 따라 연산(동작)을 수행할 때, 연산에 걸리는 시간" 이라고 할 수 있다.    
* 시간 복잡도가 높다, 느리다 = 시간이 오래 걸린다 
* 시간 복잡도가 낮다, 빠르다 = 시간이 적게 걸린다

최근 하드웨어의 성능이 매우 높아져 공간 복잡도가 큰 의미를 지니지 않기 때문에, 코드의 효율성에 대해 이야기한다면 보통 시간 복잡도를 가지고 이야기한다고 할 수 있다.

시간 복잡도를 나타내는 표기법엔 세 가지가 있다.

-   Big-O : 최악의 경우에 대한 시간 복잡도
-   Big-Ω : 최선의 경우에 대한 시간 복잡도
-   Big-θ : 평균적인 시간 복잡도

사실 이 중, 최선과 평균에 대한 시간 복잡도는 최악의 케이스가 발생할 경우 큰 의미를 갖지 못한다. 따라서 최악의 상황을 가정하고 Big-O를 기준으로 프로그래밍 하는 것이 적절하다고 할 수 있다.
아래 차트는 Big-O 표기법의 시간복잡도 차트이다.

![image](https://user-images.githubusercontent.com/110891599/192504439-18f13ea1-073d-493a-87ba-07bf3a73a2b8.png)


예시를 통해 조금 더 구체적으로 이해할 수 있다.

## **O(1)**

```java
public int getValueOfIndex(int[] arr, int n){
    return arr[n];
}
```

getValueOfIndex 메서드는 배열과 정수 n을 입력받아 배열의 n번째 인덱스의 값을 반환한다. 이 경우, n이 0이든 1000이든 1000000이든 해당 메서드는 즉시 인덱스에 접근해 값을 반환할 것 이므로, 시간에 변화가 없다. 이런 경우가 위 차트에서 O(1)에 해당한다.

## **O(n)**

```java
public int findMaximumValue(int[] arr){
	int max=0;
	for(int i=0;i<arr.length;i++){
        if(i==0) max = arr[i];
        if(arr[i]>max) max = arr[i];
    }
    return max;
}
```

findMaxiumumValue 메서드는 최댓값을 찾기 위해 배열의 전체를 한번 순회한다. 입력되는 배열의 크기를 n이라고 한다면, 시간 복잡도는 O(n)이 된다.

## **O(n^2)**

O(n)의 예시를 통해, 이중 반복문을 구성한다면 시간 복잡도가 O(n^2)이 될 것임을 예상할 수 있다. 하지만 반복문이 삼중, 사중이 되더라도 시간 복잡도는 똑같이 O(n^2)으로 표기한다.

## **O(log n)**

```java
public static int binarySearch(int answer, int low, int high, ArrayList<Integer> prime) {
	int mid;
	while (low <= high) {
		mid = (low + high) / 2;
		if (answer == prime.get(mid)) {
		    return prime.get(mid);
		} else if (answer < prime.get(mid)) {
		    high = mid - 1;
		} else {
		    low = mid + 1;
		}
	}
	return -1;
}
```

binarySearch 메서드는 이진탐색을 구현해놓은 메서드이다. 이진 탐색은 한 번 탐색할 때마다 탐색 범위가 절반으로 줄어든다. 1~100까지의 수 중에 32를 찾는과정은 다음과 같다.

-   50과 32를 비교한다. 32는 50보다 작기 때문에 다음엔 1~49의 범위에서 탐색한다.
-   1 ~ 49의 중앙값인 25와 32를 비교한다. 32는 25보다 크기 때문에 다음엔 26 ~ 49의 범위에서 탐색한다.
-   26 ~ 49의 중앙값인 37과 32를 비교한다. 32는 37보다 작기 때문에 다음엔 26 ~ 36의 범위에서 탐색한다.
-   26 ~ 36의 중앙값인 31과 32를 비교한다. 32는 31보다 크기 때문에 다음엔 32 ~ 36의 범위에서 탐색한다.
-   32 ~ 36의 중앙값인 34와 32를 비교한다. 32는 34보다 작기 때문에 다음엔 32 ~ 33의 범위에서 탐색한다.
-   32 ~ 33의 중앙값인 32와 32를 비교한다. 일치한다 = 탐색완료

이 경우, 숫자가 1~100으로 n = 100이지만 6회의 반복을 통해 탐색을 완료했다. 이런 경우 시간복잡도를 O(log n)으로 표기한다. 이는 O(1)다음으로 빠른 시간 복잡도를 지닌다.

## **O(2^n)**

O(2^n)은 exponential complexity라고 부른다. 얘는 Big-O표기법에서 가장 느린 시간 복잡도를 갖는다. 대표적으로 재귀를 통해 구현한 피보나치 수열이 O(2^n)의 시간 복잡도를 가진다.

```java
public int fibonacci(int n) {
    if(n <= 1) {
        return 1;
    }
    return fibonacci(n - 1) + fibonacci (n - 2);
}
```

n = 0 또는 1일 경우처럼 즉시 리턴이 가능하다면 O(1)이겠지만, 2만 되어도 fibonacci(0) + fibonacci(1) 로 시간복잡도가 증가하며, 3부터는 fibonacci(1) + fibonacci(2) -> fibonacci(1) + fibonacci(1) + fibonacci(0) 이 된다.

n 이 10만 되어도 89개의 fibonacci(0), fibonacci(1)을 얻을 때 까지 재귀호출이 반복된다.

n 이 20이면..? 약 만개의 숫자를 얻을 때 까지 재귀호출한다. 어지간한 경우엔 O(2^n)의 시간복잡도를 갖는 방식의 코드는 구성하지 않는 것이 좋아보인다.
