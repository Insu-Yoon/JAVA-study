# **Greedy**

greedy는 탐욕스러운, 욕심많은 등의 의미를 지닌다.   
greedy 알고리즘은 말그대로 당장 눈앞에 보이는 최적의 상황을 선택지로 고르는 과정을 거쳐 해답에 도달하는 알고리즘이다.   
탐욕 알고리즘으로 문제를 푸는 과정은 다음과 같다.

1.  선택 절차 - 현재 상태에서 최적의 선택지를 고른다.
2.  적절성 검사 - 선택한 선택지가 문제의 조건을 만족하는 지 확인한다.
3.  해답 검사 - 문제가 해결되었는지 확인하고, 해결되지 않았다면 1부터 다시 반복한다.

## **예제를 통해 살펴보기**

탐욕 알고리즘을 설명할 때 가장 많이 등장하는 예제를 통해 살펴보자.

```java
1000원짜리 지폐와 500원, 100원, 50원 동전이 있을 때
3750원을 만들기 위한 가장 적은 지폐 및 동전 수는?
```

```java
//input = 3750
public int getNumber(int input){
	//화폐의 단위를 담은 배열 -> 추후 해당 단위의 필요 갯수로 치환될 예정이다.
    int[] unit = new int[]{1000, 500, 100, 50};
	//결과를 담을 변수
    int result=0;
    int sum=0;
    //반복문 안에서 단위를 바꾸기 위한 변수
    int cnt=0;
    //큰 단위부터 반복 시작
    while(input!=0){
    //임시 변수를 만들어 input을 화폐단위로 나누고 저장
    	int temp = input/unit[cnt]; //temp = 3 //temp = 1
        input -= temp * unit[cnt];  //input = 750 //input = 250
        unit[cnt] = temp;	    //unit = {3, 500, 100, 50} //unit = {3, 1, 100, 50}
        result += unit[cnt];
        cnt++;
        }
        return result;
    }
```

주석을 통해 두번째 반복까지는 동작의 형태가 적혀있다. 3번째, 4번째 반복을 통해 input은 0이되고 반복문이 종료되며 결과를 출력할 것이다.

탐욕 알고리즘을 통해 문제를 해결한 것이다.

하지만 이는 특정한 조건이 만족되어 가능한 것이며, 특정 조건을 만족하지 못하면 탐욕 알고리즘은 최적해를 찾을 수 없다.    
예를 들어 위 문제에서 250원짜리 동전이 있었다면 천원 3장과 250원 동전 3개, 총 6 개만으로 3750원을 만들 수 있지만,    
탐욕 알고리즘을 통해 풀면 250원짜리보다 500원짜리를 먼저 선택하기 때문에 최적해에 도달할 수 없다.

## **탐욕 알고리즘 적용 조건**

탐욕 알고리즘으로 최적해를 찾기위한 조건은 다음과 같다.

-   탐욕적 선택 속성(Greedy Choice Property) : 이전의 선택이 이후의 선택에 영향을 주지 않는다.
-   최적 부분 구조(Optimal Substructure) : 부분 문제에 대한 최적 해결 방법을 통해 최종 해결 방법이 구성된다.

250원 동전이 없는 경우의 문제는 위 조건들을 만족하기 때문에 탐욕 알고리즘을 통해 최적해에 도달할 수 있지만, 250원 동전이 추가되는 경우 100원 동전으로는 250원을 구성할 수 없기 때문에, 최적 부분 구조를 갖는다는 조건을 만족시키지 못해 탐욕 알고리즘으로 해결할 수 없는 것이다.

## **근사 알고리즘**

앞에서 살펴보았듯이 탐욕 알고리즘은 항상 최적해를 도출하지는 못하지만, 최적해에 근사한 값을 빠르게 도출할 수 있다는 장점이 존재한다.    
이 장점으로 인해, 탐욕 알고리즘은 근사 알고리즘으로 사용할 수 있다.
