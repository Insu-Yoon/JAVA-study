# **들어가기전(세션 기반 자격 증명의 특징)**

-   세션은 인증된 사용자 정보를 서버 측 세션 저장소에서 관리함
-   생성된 사용자 세션의 고유한 ID인 세션 ID는 클라이언트의 쿠키에 저장되어, Request 전송 시 인증된 사용자인지를 증명하는 수단으로 사용
-   세션 ID만 클라이언트 쪽에서 사용하므로, 상대적으로 적은 네트워크 트래픽 사용
-   서버의 확장성 면에서는 세션 불일치 문제가 발생할 가능성 높음
-   세션 데이터가 많아질수록 서버의 부담이 커짐
-   SSR 방식의 앱에 적합한 방식

> 서버 확장 시 발생하는 세션 불일치 문제의 경우, Sticky Session, Session Clustering, Session 저장소의 외부 분리 등의 작업을 통해 보완할 수 있다.

# **Token 기반 자격 증명**

> **Token : 인증된 사용자 정보를 포함한, 자격 증명을 위한 도구**

-   토큰에 포함된 '인증된 사용자 정보'는 서버 측에서 별도의 관리를 하지 않음
-   생성된 토큰을 헤더에 포함시켜 request 전송 시, 인증된 사용자인지 증명하는 수단으로 사용
-   토큰 내에 인증된 사용자 정보 등을 포함하므로, 세션에 비해 상대적으로 많은 네트워크 트래픽 사용
-   서버 측에서 토큰을 관리하지 않으므로, 보안성 측면에서 비교적 불리함
-   인증된 사용자 request의 상태를 유지할 필요가 없으므로 서버의 확장성 면에서 유리하고, 세션 불일치와 같은 문제가 발생하지 않음
-   토큰에 포함되는 사용자 정보는 토큰의 특성상 암호화가 되지 않는다. 따라서 공격자에게 토큰이 탈취될 경우, 사용자 정보를 그대로 제공하게 된다. 그러므로 민감한 정보는 토큰에 포함시켜선 안된다.
-   토큰이 만료되기 전까지는 토큰을 무효화 시킬 수 없음
-   CSR 방식의 앱에 적합한 방식

> 기본적으로 토큰 무효화를 할 수 없지만, key/value 쌍의 형태로 저장되는 Redis 같은 인메모리 DB에 무효화 시키고자 하는 토큰의 만료 시간을 짧게 할당하여 해당 토큰을 사용하지 못하게 하는 등의 방법을 사용해 토큰 무효화 문제를 보완할 수 있다.

# **JWT(Json Web Token)**

> **JWT : 데이터를 안전하고 간결하게 전송하기 위해 고안된 인터넷 표준 인증 방식**  
>  **- 토큰 인증 방식에서 가장 범용적으로 사용되며, json 포맷의 토큰 정보를 인코딩 후, 인코딩 된 토큰 정보를 Secret Key로 서명한 메시지를 Web Token으로써 인증 과정에 사용한다.**

-   Access Token  : 보호된 리소스에 접근할 수 있는 '권한 부여' 에 사용
    -   실제로 권한을 얻는데에 사용하는 토큰
    -   Access Token은 비교적 짧은 유효 기간을 주어, 탈취되더라도 오랫동안 사용할 수 없도록 하는 것이 좋음
-   Refresh Token : Access Token의 유효기간이 만료되면 Refresh Token을 사용하여 새로운 Access Token을 발급
    -   새로운 Access Toekn을 발급받을 시, 사용자가 다시 로그인 인증을 할 필요는 없다.
    -   Refresh Token의 경우 탈취되면 큰 문제가 될 수 있음. 이러한 이유로 편의성보다 정보의 보호가 더 중요한 웹 앱은 Refresh Token을 사용하지 않는 곳이 많다.

## **JWT의 구조**

![image](https://user-images.githubusercontent.com/110891599/203810272-9dafbaf4-11ab-4d44-bd82-e5b7d9e5446f.png)

> **Header, Payload, Signature는 각각의 JSON 객체를 base64로 인코딩하여 각각의 블록을 완성한다.**

-   Header 가 포함하는 정보
    -   어떤 종류의 토큰인가(지금은 JWT)
    -   어떤 알고리즘으로 서명할 것인가

```javascript
{
  "alg": "HS256",
  "typ": "JWT"
}
```

-   Payload 가 포함하는 정보
    -   사용자의 정보(권한, 이름 등)
    -   Payload는 Signature를 통해 유효성이 검증될 정보이긴 하지만, 민감한 정보는 담지 않는 것이 좋음

```javascript
{
  "sub": "someInformation",
  "name": "phillip",
  "iat": 151623391
}
```

-   Signature 가 포함하는 정보
    -   Secret Key와 Header에서 지정한 알고리즘을 사용하여 Header, Payload에 대해 단방향 암호화를 수행
    -   암호하된 메시지는 토큰의 위변조 유무 검증에 사용

```javascript
//HMAC SHA256 알고리즘을 사용한다면, Signature는 아래와 같이 생성됨
HMACSHA256(base64UrlEncode(header) + '.' + base64UrlEncode(payload), secret);
```

## **JWT 사용 예시**

-   JWT는 권한 부여에 매우 유용함
    -   사용자가 앱A의 인증 서버에 로그인 정보(ID, password) 제공
    -   인증에 성공할 경우 JWT 발급
    -   해당 JWT를 사용해 다른 앱에서도 앱 A의 해당 사용자에 대한 리소스에 접근가능

## **Token 기반 인증 절차**

1.  클라이언트가 서버에 ID/Password를 담아 로그인 요청 전송
2.  ID/Password가 일치하는지 확인 후, 클라이언트에게 보낼 암호화 된 토큰 생성
    -   Access Token, Refresh Token 모두 생성
        -   토큰에 담길 정보(Payload)는 사용자를 식별할 정보, 사용자의 권한 정보 등이 될 수 있음
        -   Refresh Token을 이용해 새로운 Access Token을 생성할 것이므로, 두 종류의 토큰이 같은 정보를 담을 필요는 없다.
3.  서버가 토큰을 클라이언트에게 전송하면, 클라이언트는 토큰을 저장
    -   저장되는 위치는 Local Storage, Session Storage, cookie 등이 될 수 있음
4.  클라이언트가 HTTP Header(Authorization Header) 또는 쿠키에 토큰을 담아 request 전송
    -   Bearer authentication을 이용
5.  서버는 토큰을 검증하여 해당 서버에서 발급한 토큰이 맞다고 판단 할 경우, 클라이언트의 요청을 처리한 후 응답 전송

## **JWT의 장점**

-   상태 유지 x(Stateless), 확장 용이(Scalable)한 앱 구현하기 용이
    -   서버는 클라이언트에 대한 정보를 저장할 필요가 없다. (토큰이 정상적으로 검증되는지만 판단)
    -   클라이언트는 request를 전송할 때 마다 토큰을 헤더에 포함시키면 됨
        -   여러대의 서버를 이용한 서비스라면, 하나의 토큰으로 여러 서버에서 인증이 가능한 JWT를 사용하는 것이 효과적
        -   만약 JWT가 아닌 세션 방식이라면, 모든 서버가 해당 사용자의 세션 정보를 공유하고 있어야 함
-   클라이언트가 request를 전송할 때 마다 자격 증명 정보를 전송할 필요가 없다.
    -   HTTP Basic 같은 인증 방식의 경우, request를 전송할 때 마다 자격 증명 정보를 포함해야함
    -   하지만 JWT의 경우 토큰이 만료되기 전까지는 한번의 인증만 수행하면 됨
-   인증을 담당하는 시스템을 다른 플랫폼으로 분리하는 것이 용이함
    -   사용자의 자격 증명 정보를 직접 관리하지 않고, Github, Google 등의 다른 플랫폼의 자격 증명 정보로 인증하는 것이 가능함
    -   토큰 생성용 서버를 따로 만들거나, 타 회사에 토큰 관련 작업을 맡기는 등 다양한 활용이 가능함
-   권한 부여에 용이함
    -   토큰의 Payload 안에 해당 사용자의 권한 정보를 포함하는 것이 용이함

## **JWT의 단점**

-   Payload는 디코딩이 용이함
    -   Payload는 base64로 인코딩되므로, 토큰을 탈취하여 Payload를 디코딩하면 토큰 생성 시 저장한 데이터를 확인하는 것이 가능하다. 따라서 Payload에는 민감한 정보를 포함해서는 안된다.
-   토큰의 길이가 길어지면 네트워크에 부하를 줄 수 있음
    -   토큰에 저장하는 정보의 양이 많아질수록, 토큰의 길이는 길어짐
    -   request를 전송할 때 마다 긴 토큰을 전송해야 하므로, 네트워크에 부하를 줄 수 있음
-   토큰은 자동으로 삭제되지 않음
    -   한 번 생성된 토큰은 자동으로 삭제되지 않기 때문에, 토큰 만료 시간을 반드시 추가해야 함
    -   토큰이 탈취된 경우, 토큰의 기한이 만료될 때 까지 해당 토큰을 이용할 수 있으므로, 만료 시간을 너무 길게 설정하지 않아야 함
